#!/usr/bin/perl -w
use strict;
use Posda::DB 'Query';
use Digest::MD5;
use Posda::BackgroundProcess;
use Posda::DB::PosdaFilesQueries;
use Socket;

my $usage = <<EOF;
SetUpPublicToPosdaCopy.pl <bkgrnd_id> <collection> <notify> <why_done>
or
PublicPosdaCompare.pl -h

The script doesn't expect lines on STDIN:
It generates lists of SOP Uids for a collection on both public and posda
and does a compare of the lists.

If the SOPS match exactly, then it sets up the following tables
  copy_from_public
  file_copy_from_public

It will create a single row in copy_from_public to control the copy.  It 
creates a row in file_copy_from_public for each file to be copied.

The copy is actually done by the operation CopyFilesFromPublic.  It requires
only the id of the copy_from_public row.  This id is contained in the Email
generated by this script

EOF
$| = 1;
if($#ARGV == 0 && $ARGV[0] eq "-h"){
  print "$usage\n";
  exit;
}
unless($#ARGV == 3){ die "$usage\n"; }
my ($invoc_id, $collection, $notify, $why_done) = @ARGV;

my $background = Posda::BackgroundProcess->new($invoc_id, $notify);

print "Entering Background\n";

$background->Daemonize;
my $bk_id = $background->GetBackgroundID;
my $start_time = `date`;
chomp $start_time;
$background->WriteToEmail("BackgroundProcess Id: $bk_id\n");
$background->WriteToEmail("Starting Public to Posda Copy " .
  "for collection $collection at $start_time\n");
$background->WriteToEmail("Starting Public/Posda Comparison " .
  "for collection $collection\n");

my $get_posda_counts = Query("GetPosdaSopsForCompare");
my $get_public_counts = Query("GetPublicSopsForCompare");
my %PosdaHierarchy;
my %PosdaSops;
my %PosdaDup1Sops;
my %PosdaDup2Sops;
my %PosdaMultiDupSops;
my %PublicHierarchy;
my %PublicSops;
$get_posda_counts->RunQuery(sub {
    my($row) = @_;
    my $patient_id = $row->[0];
    my $study_uid = $row->[1];
    my $series_uid = $row->[2];
    my $sop_inst = $row->[3];
    my $sop_class = $row->[4];
    my $modality = $row->[5];
    my $dicom_file_type = $row->[6];
    my $file_path = $row->[7];
    my $file_id = $row->[8];
    my $h = {
       pat_id => $patient_id,
       study_uid => $study_uid,
       series_uid => $series_uid,
       sop_inst => $sop_inst,
       sop_class => $sop_class,
       modality => $modality,
       dicom_file_type => $dicom_file_type,
       file_path => $file_path,
       file_id => $file_id,
    };
    if(exists $PosdaSops{$sop_inst}){
      if(exists $PosdaDup1Sops{$sop_inst}){
        $PosdaDup2Sops{$sop_inst} = $h;
      } else {
        $PosdaDup1Sops{$sop_inst} = $h;
      }
    } else {
      $PosdaSops{$sop_inst} = $h;
      $PosdaHierarchy{$patient_id}->{$study_uid}->{$series_uid}
         ->{$sop_inst} = $PosdaSops{$sop_inst};
    }
  }, sub {},
  $ARGV[1]
);
$get_public_counts->RunQuery(sub {
    my($row) = @_;
    my $patient_id = $row->[0];
    my $study_uid = $row->[1];
    my $series_uid = $row->[2];
    my $sop_inst = $row->[3];
    my $sop_class = $row->[4];
    my $modality = $row->[5];
    my $dicom_file_uri = $row->[6];
    $dicom_file_uri =~ s/^.*\/storage/\/nas\/public\/storage/;
    $PublicSops{$sop_inst} = {
       pat_id => $patient_id,
       study_uid => $study_uid,
       series_uid => $series_uid,
       sop_inst => $sop_inst,
       sop_class => $sop_class,
       modality => $modality,
       file_path => $dicom_file_uri,
    };
    $PublicHierarchy{$patient_id}->{$study_uid}->{$series_uid}
       ->{$sop_inst} = $PublicSops{$sop_inst};
  }, sub {},
  $ARGV[1]
);
my %OnlyInPosda;
my %OnlyInPublic;
my %InBoth;
for my $sop (keys %PosdaSops){
  unless(exists $PublicSops{$sop}) { $OnlyInPosda{$sop} = 1 }
  else { $InBoth{$sop} = 1 }
}
for my $sop (keys %PublicSops){
  unless(exists $PosdaSops{$sop}) { $OnlyInPublic{$sop} = 1 }
}
my $only_in_posda = keys %OnlyInPosda;
my $only_in_public = keys %OnlyInPublic;
my $in_both = keys %InBoth;
my $finished_compare_time = `date`;
chomp $finished_compare_time;
$background->WriteToEmail("Finished Compare at: $finished_compare_time\n");
$background->WriteToEmail(
  "There are $only_in_posda files which are only in Posda\n" .
  "There are $only_in_public files which are only in Public\n" .
  "There are $in_both files which are in Both\n");
unless($only_in_posda == 0 && $only_in_public == 0){
  $background->WriteToEmail(
    "Refusing to copy unless SOP counts match for Public and Posda\n");
  $background->Finish;
  exit;
}
#####
#$background->WriteToEmail("Just testing first part of script\n");
#$background->Finish;
#exit;
####
my $create_copy_from_public = Query("CreateCopyFromPublicEntry");
$create_copy_from_public->RunQuery(sub {}, sub {},
  $notify, $why_done, "creating event");
my $get_copy_from_public_id = Query("GetIdOfNewCopyFromPublicRow");
my $copy_id;
$get_copy_from_public_id->RunQuery(sub {
  my($row) = @_;
  $copy_id = $row->[0];
}, sub {});
unless(defined $copy_id){
  $background->WriteToEmail("Unable to get id of copy_from_public row\n");
  $background->Finish;
  exit;
}
my $insert_file_copy = Query('InsertFileCopyFromPublicRow');
my $num_file_rows = 0;
for my $sop(keys %InBoth){
  my $file_id = $PosdaSops{$sop}->{file_id};
  my $file_path = $PublicSops{$sop}->{file_path};
  $insert_file_copy->RunQuery(sub {}, sub {}, 
    $copy_id, $sop, $file_id, $file_path);
  $num_file_rows += 1;
}
my $update_copy_from_public = Query("UpdateCopyFromPublic");
$update_copy_from_public->RunQuery(sub{}, sub{},
  $num_file_rows, "waiting for start", $copy_id);
my $finished_setup_time = `date`;
chomp $finished_setup_time;
$background->WriteToEmail("    Finished Setup of Copy at: " .
  "$finished_setup_time:\n");
$background->WriteToEmail("Id of row in copy_from_public: $copy_id\n");
$background->WriteToEmail(" Number of files to be copied: $num_file_rows\n");
$background->Finish;
